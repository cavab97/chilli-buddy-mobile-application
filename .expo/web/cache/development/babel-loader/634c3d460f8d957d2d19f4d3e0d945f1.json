{"ast":null,"code":"'use strict';\n\nimport _extends from \"@babel/runtime/helpers/extends\";\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nimport AnimatedValue from \"./AnimatedValue\";\nimport AnimatedNode from \"./AnimatedNode\";\nimport { generateNewAnimationId, shouldUseNativeDriver } from \"../NativeAnimatedHelper\";\n\nvar AnimatedTracking = function (_AnimatedNode) {\n  _inherits(AnimatedTracking, _AnimatedNode);\n\n  function AnimatedTracking(value, parent, animationClass, animationConfig, callback) {\n    _classCallCheck(this, AnimatedTracking);\n\n    var _this = _possibleConstructorReturn(this, _AnimatedNode.call(this));\n\n    _this._value = value;\n    _this._parent = parent;\n    _this._animationClass = animationClass;\n    _this._animationConfig = animationConfig;\n    _this._useNativeDriver = shouldUseNativeDriver(animationConfig);\n    _this._callback = callback;\n\n    _this.__attach();\n\n    return _this;\n  }\n\n  AnimatedTracking.prototype.__makeNative = function __makeNative() {\n    this.__isNative = true;\n\n    this._parent.__makeNative();\n\n    _AnimatedNode.prototype.__makeNative.call(this);\n\n    this._value.__makeNative();\n  };\n\n  AnimatedTracking.prototype.__getValue = function __getValue() {\n    return this._parent.__getValue();\n  };\n\n  AnimatedTracking.prototype.__attach = function __attach() {\n    this._parent.__addChild(this);\n\n    if (this._useNativeDriver) {\n      this.__makeNative();\n    }\n  };\n\n  AnimatedTracking.prototype.__detach = function __detach() {\n    this._parent.__removeChild(this);\n\n    _AnimatedNode.prototype.__detach.call(this);\n  };\n\n  AnimatedTracking.prototype.update = function update() {\n    this._value.animate(new this._animationClass(_extends({}, this._animationConfig, {\n      toValue: this._animationConfig.toValue.__getValue()\n    })), this._callback);\n  };\n\n  AnimatedTracking.prototype.__getNativeConfig = function __getNativeConfig() {\n    var animation = new this._animationClass(_extends({}, this._animationConfig, {\n      toValue: undefined\n    }));\n\n    var animationConfig = animation.__getNativeAnimationConfig();\n\n    return {\n      type: 'tracking',\n      animationId: generateNewAnimationId(),\n      animationConfig: animationConfig,\n      toValue: this._parent.__getNativeTag(),\n      value: this._value.__getNativeTag()\n    };\n  };\n\n  return AnimatedTracking;\n}(AnimatedNode);\n\nexport default AnimatedTracking;","map":{"version":3,"sources":["C:/Users/User/Desktop/ZuMei/gogogainUser/node_modules/react-native-web/dist/vendor/react-native/Animated/nodes/AnimatedTracking.js"],"names":["_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","call","ReferenceError","_inherits","subClass","superClass","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","AnimatedValue","AnimatedNode","generateNewAnimationId","shouldUseNativeDriver","AnimatedTracking","_AnimatedNode","parent","animationClass","animationConfig","callback","_this","_value","_parent","_animationClass","_animationConfig","_useNativeDriver","_callback","__attach","__makeNative","__isNative","__getValue","__addChild","__detach","__removeChild","update","animate","toValue","__getNativeConfig","animation","undefined","__getNativeAnimationConfig","type","animationId","__getNativeTag"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n'use strict';\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nimport AnimatedValue from './AnimatedValue';\nimport AnimatedNode from './AnimatedNode';\nimport { generateNewAnimationId, shouldUseNativeDriver } from '../NativeAnimatedHelper';\n\nvar AnimatedTracking = function (_AnimatedNode) {\n  _inherits(AnimatedTracking, _AnimatedNode);\n\n  function AnimatedTracking(value, parent, animationClass, animationConfig, callback) {\n    _classCallCheck(this, AnimatedTracking);\n\n    var _this = _possibleConstructorReturn(this, _AnimatedNode.call(this));\n\n    _this._value = value;\n    _this._parent = parent;\n    _this._animationClass = animationClass;\n    _this._animationConfig = animationConfig;\n    _this._useNativeDriver = shouldUseNativeDriver(animationConfig);\n    _this._callback = callback;\n    _this.__attach();\n    return _this;\n  }\n\n  AnimatedTracking.prototype.__makeNative = function __makeNative() {\n    this.__isNative = true;\n    this._parent.__makeNative();\n    _AnimatedNode.prototype.__makeNative.call(this);\n    this._value.__makeNative();\n  };\n\n  AnimatedTracking.prototype.__getValue = function __getValue() {\n    return this._parent.__getValue();\n  };\n\n  AnimatedTracking.prototype.__attach = function __attach() {\n    this._parent.__addChild(this);\n    if (this._useNativeDriver) {\n      // when the tracking starts we need to convert this node to a \"native node\"\n      // so that the parent node will be made \"native\" too. This is necessary as\n      // if we don't do this `update` method will get called. At that point it\n      // may be too late as it would mean the JS driver has already started\n      // updating node values\n      this.__makeNative();\n    }\n  };\n\n  AnimatedTracking.prototype.__detach = function __detach() {\n    this._parent.__removeChild(this);\n    _AnimatedNode.prototype.__detach.call(this);\n  };\n\n  AnimatedTracking.prototype.update = function update() {\n    this._value.animate(new this._animationClass(Object.assign({}, this._animationConfig, {\n      toValue: this._animationConfig.toValue.__getValue()\n    })), this._callback);\n  };\n\n  AnimatedTracking.prototype.__getNativeConfig = function __getNativeConfig() {\n    var animation = new this._animationClass(Object.assign({}, this._animationConfig, {\n      // remove toValue from the config as it's a ref to Animated.Value\n      toValue: undefined\n    }));\n    var animationConfig = animation.__getNativeAnimationConfig();\n    return {\n      type: 'tracking',\n      animationId: generateNewAnimationId(),\n      animationConfig: animationConfig,\n      toValue: this._parent.__getNativeTag(),\n      value: this._value.__getNativeTag()\n    };\n  };\n\n  return AnimatedTracking;\n}(AnimatedNode);\n\nexport default AnimatedTracking;"]},"metadata":{},"sourceType":"module"}