{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/extends\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nvar _jsxFileName = \"C:\\\\Users\\\\User\\\\Desktop\\\\ZuMei\\\\gogogainUser\\\\node_modules\\\\react-native-easy-view-transformer\\\\src\\\\index.js\";\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nimport React from \"react\";\nimport View from \"react-native-web/dist/exports/View\";\nimport Animated from \"react-native-web/dist/exports/Animated\";\nimport Easing from \"react-native-web/dist/exports/Easing\";\nimport NativeModules from \"react-native-web/dist/exports/NativeModules\";\nimport findNodeHandle from \"react-native-web/dist/exports/findNodeHandle\";\nimport Scrolling from \"react-native-scrolling\";\nimport PropTypes from \"prop-types\";\nimport { createResponder } from \"react-native-easy-guesture-responder\";\nimport { Rect, Transform, transformedRect, availableTranslateSpace, fitCenterRect, alignedRect, getTransform } from \"./TransformUtils\";\n\nvar ViewTransformer = function (_React$Component) {\n  _inherits(ViewTransformer, _React$Component);\n\n  var _super = _createSuper(ViewTransformer);\n\n  function ViewTransformer(props) {\n    var _this;\n\n    _classCallCheck(this, ViewTransformer);\n\n    _this = _super.call(this, props);\n    _this.state = {\n      scale: 1,\n      translateX: 0,\n      translateY: 0,\n      animator: new Animated.Value(0),\n      width: 0,\n      height: 0,\n      pageX: 0,\n      pageY: 0\n    };\n    _this._viewPortRect = new Rect();\n    _this.onLayout = _this.onLayout.bind(_assertThisInitialized(_this));\n    _this.cancelAnimation = _this.cancelAnimation.bind(_assertThisInitialized(_this));\n    _this.contentRect = _this.contentRect.bind(_assertThisInitialized(_this));\n    _this.transformedContentRect = _this.transformedContentRect.bind(_assertThisInitialized(_this));\n    _this.animate = _this.animate.bind(_assertThisInitialized(_this));\n    _this.onResponderGrant = _this.onResponderGrant.bind(_assertThisInitialized(_this));\n    _this.onResponderRelease = _this.onResponderRelease.bind(_assertThisInitialized(_this));\n    _this.onResponderMove = _this.onResponderMove.bind(_assertThisInitialized(_this));\n    _this.scroller = new Scrolling(true, function (dx, dy, scroller) {\n      if (dx === 0 && dy === 0 && scroller.isFinished()) {\n        _this.animateBounce();\n\n        return;\n      }\n\n      _this.updateTransform({\n        translateX: _this.state.translateX + dx / _this.state.scale,\n        translateY: _this.state.translateY + dy / _this.state.scale\n      });\n    });\n    return _this;\n  }\n\n  _createClass(ViewTransformer, [{\n    key: \"viewPortRect\",\n    value: function viewPortRect() {\n      this._viewPortRect.set(0, 0, this.state.width, this.state.height);\n\n      return this._viewPortRect;\n    }\n  }, {\n    key: \"contentRect\",\n    value: function contentRect() {\n      var rect = this.viewPortRect().copy();\n\n      if (this.props.contentAspectRatio && this.props.contentAspectRatio > 0) {\n        rect = fitCenterRect(this.props.contentAspectRatio, rect);\n      }\n\n      return rect;\n    }\n  }, {\n    key: \"transformedContentRect\",\n    value: function transformedContentRect() {\n      var rect = transformedRect(this.viewPortRect(), this.currentTransform());\n\n      if (this.props.contentAspectRatio && this.props.contentAspectRatio > 0) {\n        rect = fitCenterRect(this.props.contentAspectRatio, rect);\n      }\n\n      return rect;\n    }\n  }, {\n    key: \"currentTransform\",\n    value: function currentTransform() {\n      return new Transform(this.state.scale, this.state.translateX, this.state.translateY);\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this2 = this;\n\n      this.gestureResponder = createResponder({\n        onStartShouldSetResponder: function onStartShouldSetResponder(evt, gestureState) {\n          return true;\n        },\n        onMoveShouldSetResponderCapture: function onMoveShouldSetResponderCapture(evt, gestureState) {\n          return true;\n        },\n        onResponderMove: this.onResponderMove,\n        onResponderGrant: this.onResponderGrant,\n        onResponderRelease: this.onResponderRelease,\n        onResponderTerminate: this.onResponderRelease,\n        onResponderTerminationRequest: function onResponderTerminationRequest(evt, gestureState) {\n          return false;\n        },\n        onResponderDoubleTapConfirmed: function onResponderDoubleTapConfirmed(evt, gestureState) {\n          _this2.props.onDoubleTapConfirmed && _this2.props.onDoubleTapConfirmed();\n        },\n        onResponderSingleTapConfirmed: function onResponderSingleTapConfirmed(evt, gestureState) {\n          _this2.props.onSingleTapConfirmed && _this2.props.onSingleTapConfirmed();\n        }\n      });\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps, prevState) {\n      this.props.onViewTransformed && this.props.onViewTransformed({\n        scale: this.state.scale,\n        translateX: this.state.translateX,\n        translateY: this.state.translateY\n      });\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.cancelAnimation();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this3 = this;\n\n      var gestureResponder = this.gestureResponder;\n\n      if (!this.props.enableTransform) {\n        gestureResponder = {};\n      }\n\n      return React.createElement(View, _extends({\n        style: {\n          flex: 1\n        }\n      }, this.props, gestureResponder, {\n        ref: function ref(component) {\n          return _this3.innerViewRef = component;\n        },\n        onLayout: this.onLayout,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 168,\n          columnNumber: 13\n        }\n      }), React.createElement(View, {\n        style: {\n          flex: 1,\n          transform: [{\n            scale: this.state.scale\n          }, {\n            translateX: this.state.translateX\n          }, {\n            translateY: this.state.translateY\n          }]\n        },\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 174,\n          columnNumber: 17\n        }\n      }, this.props.children));\n    }\n  }, {\n    key: \"onLayout\",\n    value: function onLayout(e) {\n      var _e$nativeEvent$layout = e.nativeEvent.layout,\n          width = _e$nativeEvent$layout.width,\n          height = _e$nativeEvent$layout.height;\n\n      if (width !== this.state.width || height !== this.state.height) {\n        this.setState({\n          width: width,\n          height: height\n        });\n      }\n\n      this.measureLayout();\n      this.props.onLayout && this.props.onLayout(e);\n    }\n  }, {\n    key: \"measureLayout\",\n    value: function measureLayout() {\n      var _this4 = this;\n\n      var handle = findNodeHandle(this.innerViewRef);\n      NativeModules.UIManager.measure(handle, function (x, y, width, height, pageX, pageY) {\n        if (typeof pageX === \"number\" && typeof pageY === \"number\") {\n          if (_this4.state.pageX !== pageX || _this4.state.pageY !== pageY) {\n            _this4.setState({\n              pageX: pageX,\n              pageY: pageY\n            });\n          }\n        }\n      });\n    }\n  }, {\n    key: \"onResponderGrant\",\n    value: function onResponderGrant(evt, gestureState) {\n      this.props.onTransformStart && this.props.onTransformStart();\n      this.setState({\n        responderGranted: true\n      });\n      this.measureLayout();\n    }\n  }, {\n    key: \"onResponderMove\",\n    value: function onResponderMove(evt, gestureState) {\n      this.cancelAnimation();\n      var dx = gestureState.moveX - gestureState.previousMoveX;\n      var dy = gestureState.moveY - gestureState.previousMoveY;\n\n      if (this.props.enableResistance) {\n        var d = this.applyResistance(dx, dy);\n        dx = d.dx;\n        dy = d.dy;\n      }\n\n      if (!this.props.enableTranslate) {\n        dx = dy = 0;\n      }\n\n      var transform = {};\n\n      if (gestureState.previousPinch && gestureState.pinch && this.props.enableScale) {\n        var scaleBy = gestureState.pinch / gestureState.previousPinch;\n        var pivotX = gestureState.moveX - this.state.pageX;\n        var pivotY = gestureState.moveY - this.state.pageY;\n        var rect = transformedRect(transformedRect(this.contentRect(), this.currentTransform()), new Transform(scaleBy, dx, dy, {\n          x: pivotX,\n          y: pivotY\n        }));\n        transform = getTransform(this.contentRect(), rect);\n        this.props.onPinchTransforming && this.props.onPinchTransforming(transform);\n      } else {\n        if (Math.abs(dx) > 2 * Math.abs(dy)) {\n          dy = 0;\n        } else if (Math.abs(dy) > 2 * Math.abs(dx)) {\n          dx = 0;\n        }\n\n        transform.translateX = this.state.translateX + dx / this.state.scale;\n        transform.translateY = this.state.translateY + dy / this.state.scale;\n      }\n\n      this.updateTransform(transform);\n      var curScale = this.state.scale;\n\n      if (curScale <= 1) {\n        this.props.onPinchStartReached && this.props.onPinchStartReached(transform);\n      }\n\n      if (curScale >= this.props.maxScale) {\n        this.props.onPinchEndReached && this.props.onPinchEndReached(transform);\n      }\n\n      return true;\n    }\n  }, {\n    key: \"onResponderRelease\",\n    value: function onResponderRelease(evt, gestureState) {\n      var transform = {\n        scale: this.state.scale,\n        translateX: this.state.translateX,\n        translateY: this.state.translateY\n      };\n\n      if (gestureState.doubleTapUp) {\n        if (!this.props.enableScale) {\n          this.animateBounce();\n          return;\n        }\n\n        var pivotX = 0;\n        var pivotY = 0;\n\n        if (gestureState.dx || gestureState.dy) {\n          pivotX = gestureState.moveX - this.state.pageX;\n          pivotY = gestureState.moveY - this.state.pageY;\n        } else {\n          pivotX = gestureState.x0 - this.state.pageX;\n          pivotY = gestureState.y0 - this.state.pageY;\n        }\n\n        this.performDoubleTapUp(pivotX, pivotY);\n      } else {\n        if (this.props.enableTranslate) {\n          this.performFling(gestureState.vx, gestureState.vy);\n        } else {\n          this.animateBounce();\n        }\n      }\n\n      this.props.onTransformGestureReleased && this.props.onTransformGestureReleased(transform);\n\n      if (this.props.onSwipeUpReleased) {\n        if (this.state.scale === 1 && this.state.translateY < -150) {\n          this.props.onSwipeUpReleased(transform);\n        }\n      }\n\n      if (this.props.onSwipeDownReleased) {\n        if (this.state.scale === 1 && this.state.translateY > 150) {\n          this.props.onSwipeDownReleased(transform);\n        }\n      }\n    }\n  }, {\n    key: \"performFling\",\n    value: function performFling(vx, vy) {\n      var startX = 0;\n      var startY = 0;\n      var maxX, minX, maxY, minY;\n      var availablePanDistance = availableTranslateSpace(this.transformedContentRect(), this.viewPortRect());\n\n      if (vx > 0) {\n        minX = 0;\n\n        if (availablePanDistance.left > 0) {\n          maxX = availablePanDistance.left + this.props.maxOverScrollDistance;\n        } else {\n          maxX = 0;\n        }\n      } else {\n        maxX = 0;\n\n        if (availablePanDistance.right > 0) {\n          minX = -availablePanDistance.right - this.props.maxOverScrollDistance;\n        } else {\n          minX = 0;\n        }\n      }\n\n      if (vy > 0) {\n        minY = 0;\n\n        if (availablePanDistance.top > 0) {\n          maxY = availablePanDistance.top + this.props.maxOverScrollDistance;\n        } else {\n          maxY = 0;\n        }\n      } else {\n        maxY = 0;\n\n        if (availablePanDistance.bottom > 0) {\n          minY = -availablePanDistance.bottom - this.props.maxOverScrollDistance;\n        } else {\n          minY = 0;\n        }\n      }\n\n      vx *= 1000;\n      vy *= 1000;\n\n      if (Math.abs(vx) > 2 * Math.abs(vy)) {\n        vy = 0;\n      } else if (Math.abs(vy) > 2 * Math.abs(vx)) {\n        vx = 0;\n      }\n\n      this.scroller.fling(startX, startY, vx, vy, minX, maxX, minY, maxY);\n    }\n  }, {\n    key: \"performDoubleTapUp\",\n    value: function performDoubleTapUp(pivotX, pivotY) {\n      var curScale = this.state.scale;\n      var scaleBy;\n\n      if (curScale > (1 + this.props.maxScale) / 2) {\n        scaleBy = 1 / curScale;\n      } else {\n        scaleBy = this.props.maxScale / curScale;\n      }\n\n      var rect = transformedRect(this.transformedContentRect(), new Transform(scaleBy, 0, 0, {\n        x: pivotX,\n        y: pivotY\n      }));\n      rect = transformedRect(rect, new Transform(1, this.viewPortRect().centerX() - pivotX, this.viewPortRect().centerY() - pivotY));\n      rect = alignedRect(rect, this.viewPortRect());\n      this.animate(rect);\n\n      if (this.props.onDoubleTapStartReached || this.props.onDoubleTapEndReached) {\n        var transform = getTransform(this.contentRect(), rect);\n\n        if (curScale > (1 + this.props.maxScale) / 2) {\n          this.props.onDoubleTapStartReached && this.props.onDoubleTapStartReached(transform);\n        } else {\n          this.props.onDoubleTapEndReached && this.props.onDoubleTapEndReached(transform);\n        }\n      }\n    }\n  }, {\n    key: \"applyResistance\",\n    value: function applyResistance(dx, dy) {\n      var availablePanDistance = availableTranslateSpace(this.transformedContentRect(), this.viewPortRect());\n\n      if (dx > 0 && availablePanDistance.left < 0 || dx < 0 && availablePanDistance.right < 0) {\n        var resistantStrHorizontal = this.props.resistantStrHorizontal;\n\n        switch (typeof resistantStrHorizontal) {\n          case \"function\":\n            var returnValue = resistantStrHorizontal(dx);\n\n            if (typeof returnValue === \"number\") {\n              dx = returnValue;\n              break;\n            }\n\n            if (typeof returnValue === \"string\") {\n              dx = parseFloat(returnValue);\n              break;\n            }\n\n            console.warn(\"react-native-gallery-swiper\", \"Invalid return value for 'resistantStrHorizontal' prop. \" + \"Expecting one of 'number' or 'string'.\");\n            dx = dx /= 3;\n            break;\n\n          case \"number\":\n            dx = resistantStrHorizontal;\n            break;\n\n          case \"string\":\n            dx = parseFloat(resistantStrHorizontal);\n            break;\n\n          default:\n            dx = dx /= 3;\n            break;\n        }\n      }\n\n      if (dy > 0 && availablePanDistance.top < 0 || dy < 0 && availablePanDistance.bottom < 0) {\n        var resistantStrVertical = this.props.resistantStrVertical;\n\n        switch (typeof resistantStrVertical) {\n          case \"function\":\n            var _returnValue = resistantStrVertical(dx);\n\n            if (typeof _returnValue === \"number\") {\n              dx = _returnValue;\n              break;\n            }\n\n            if (typeof _returnValue === \"string\") {\n              dx = parseFloat(_returnValue);\n              break;\n            }\n\n            console.warn(\"react-native-gallery-swiper\", \"Invalid return value for 'resistantStrVertical' prop. \" + \"Expecting one of 'number' or 'string'.\");\n            dx = dx /= 3;\n            break;\n\n          case \"number\":\n            dy = resistantStrVertical;\n            break;\n\n          case \"string\":\n            dy = parseFloat(resistantStrVertical);\n            break;\n\n          default:\n            dy = dy /= 3;\n            break;\n        }\n      }\n\n      return {\n        dx: dx,\n        dy: dy\n      };\n    }\n  }, {\n    key: \"cancelAnimation\",\n    value: function cancelAnimation() {\n      this.state.animator.stopAnimation();\n    }\n  }, {\n    key: \"animate\",\n    value: function animate(targetRect, durationInMillis) {\n      var _this5 = this;\n\n      var duration = 200;\n\n      if (durationInMillis) {\n        duration = durationInMillis;\n      }\n\n      var fromRect = this.transformedContentRect();\n\n      if (fromRect.equals(targetRect, 0.01)) {\n        return;\n      }\n\n      this.state.animator.removeAllListeners();\n      this.state.animator.setValue(0);\n      this.state.animator.addListener(function (state) {\n        var progress = state.value;\n        var left = fromRect.left + (targetRect.left - fromRect.left) * progress;\n        var right = fromRect.right + (targetRect.right - fromRect.right) * progress;\n        var top = fromRect.top + (targetRect.top - fromRect.top) * progress;\n        var bottom = fromRect.bottom + (targetRect.bottom - fromRect.bottom) * progress;\n        var transform = getTransform(_this5.contentRect(), new Rect(left, top, right, bottom));\n\n        _this5.updateTransform(transform);\n      });\n      Animated.timing(this.state.animator, {\n        toValue: 1,\n        duration: duration,\n        easing: Easing.inOut(Easing.ease)\n      }).start();\n    }\n  }, {\n    key: \"animateBounce\",\n    value: function animateBounce() {\n      var curScale = this.state.scale;\n      var minScale = 1;\n      var maxScale = this.props.maxScale;\n      var scaleBy = 1;\n\n      if (curScale > maxScale) {\n        scaleBy = maxScale / curScale;\n      } else if (curScale < minScale) {\n        scaleBy = minScale / curScale;\n      }\n\n      var rect = transformedRect(this.transformedContentRect(), new Transform(scaleBy, 0, 0, {\n        x: this.viewPortRect().centerX(),\n        y: this.viewPortRect().centerY()\n      }));\n      rect = alignedRect(rect, this.viewPortRect());\n      this.animate(rect);\n    }\n  }, {\n    key: \"updateTransform\",\n    value: function updateTransform(transform) {\n      this.setState(transform);\n    }\n  }, {\n    key: \"forceUpdateTransform\",\n    value: function forceUpdateTransform(transform) {\n      this.setState(transform);\n    }\n  }, {\n    key: \"getAvailableTranslateSpace\",\n    value: function getAvailableTranslateSpace() {\n      return availableTranslateSpace(this.transformedContentRect(), this.viewPortRect());\n    }\n  }]);\n\n  return ViewTransformer;\n}(React.Component);\n\nViewTransformer.Rect = Rect;\nViewTransformer.getTransform = getTransform;\nViewTransformer.propTypes = {\n  enableTransform: PropTypes.bool,\n  enableScale: PropTypes.bool,\n  enableTranslate: PropTypes.bool,\n  maxOverScrollDistance: PropTypes.number,\n  maxScale: PropTypes.number,\n  contentAspectRatio: PropTypes.number,\n  enableResistance: PropTypes.bool,\n  resistantStrHorizontal: PropTypes.oneOfType([PropTypes.func, PropTypes.number, PropTypes.string]),\n  resistantStrVertical: PropTypes.oneOfType([PropTypes.func, PropTypes.number, PropTypes.string]),\n  onTransformStart: PropTypes.func,\n  onViewTransformed: PropTypes.func,\n  onPinchTransforming: PropTypes.func,\n  onPinchStartReached: PropTypes.func,\n  onPinchEndReached: PropTypes.func,\n  onTransformGestureReleased: PropTypes.func,\n  onSwipeUpReleased: PropTypes.func,\n  onSwipeDownReleased: PropTypes.func,\n  onDoubleTapStartReached: PropTypes.func,\n  onDoubleTapEndReached: PropTypes.func,\n  onDoubleTapConfirmed: PropTypes.func,\n  onSingleTapConfirmed: PropTypes.func,\n  onLayout: PropTypes.func,\n  children: PropTypes.node\n};\nViewTransformer.defaultProps = {\n  maxOverScrollDistance: 20,\n  enableScale: true,\n  enableTranslate: true,\n  enableTransform: true,\n  maxScale: 1,\n  enableResistance: false,\n  resistantStrHorizontal: function resistantStrHorizontal(dx) {\n    return dx /= 3;\n  },\n  resistantStrVertical: function resistantStrVertical(dy) {\n    return dy /= 3;\n  }\n};\nexport { ViewTransformer as default };","map":{"version":3,"sources":["C:/Users/User/Desktop/ZuMei/gogogainUser/node_modules/react-native-easy-view-transformer/src/index.js"],"names":["React","Scrolling","PropTypes","createResponder","Rect","Transform","transformedRect","availableTranslateSpace","fitCenterRect","alignedRect","getTransform","ViewTransformer","props","state","scale","translateX","translateY","animator","Animated","Value","width","height","pageX","pageY","_viewPortRect","onLayout","bind","cancelAnimation","contentRect","transformedContentRect","animate","onResponderGrant","onResponderRelease","onResponderMove","scroller","dx","dy","isFinished","animateBounce","updateTransform","set","rect","viewPortRect","copy","contentAspectRatio","currentTransform","gestureResponder","onStartShouldSetResponder","evt","gestureState","onMoveShouldSetResponderCapture","onResponderTerminate","onResponderTerminationRequest","onResponderDoubleTapConfirmed","onDoubleTapConfirmed","onResponderSingleTapConfirmed","onSingleTapConfirmed","prevProps","prevState","onViewTransformed","enableTransform","flex","component","innerViewRef","transform","children","e","nativeEvent","layout","setState","measureLayout","handle","findNodeHandle","NativeModules","UIManager","measure","x","y","onTransformStart","responderGranted","moveX","previousMoveX","moveY","previousMoveY","enableResistance","d","applyResistance","enableTranslate","previousPinch","pinch","enableScale","scaleBy","pivotX","pivotY","onPinchTransforming","Math","abs","curScale","onPinchStartReached","maxScale","onPinchEndReached","doubleTapUp","x0","y0","performDoubleTapUp","performFling","vx","vy","onTransformGestureReleased","onSwipeUpReleased","onSwipeDownReleased","startX","startY","maxX","minX","maxY","minY","availablePanDistance","left","maxOverScrollDistance","right","top","bottom","fling","centerX","centerY","onDoubleTapStartReached","onDoubleTapEndReached","resistantStrHorizontal","returnValue","parseFloat","console","warn","resistantStrVertical","stopAnimation","targetRect","durationInMillis","duration","fromRect","equals","removeAllListeners","setValue","addListener","progress","value","timing","toValue","easing","Easing","inOut","ease","start","minScale","Component","propTypes","bool","number","oneOfType","func","string","node","defaultProps"],"mappings":"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","sourcesContent":["import React from \"react\";\nimport {\n    View, Animated, Easing, NativeModules, findNodeHandle\n} from \"react-native\";\nimport Scrolling from \"react-native-scrolling\";\nimport PropTypes from \"prop-types\";\nimport { createResponder } from \"react-native-easy-guesture-responder\";\nimport {\n    Rect, Transform, transformedRect, availableTranslateSpace,\n    fitCenterRect, alignedRect, getTransform\n} from \"./TransformUtils\";\n\nexport default class ViewTransformer extends React.Component {\n    static Rect = Rect;\n    static getTransform = getTransform;\n\n    static propTypes = {\n        enableTransform: PropTypes.bool,\n        enableScale: PropTypes.bool,\n        enableTranslate: PropTypes.bool,\n        maxOverScrollDistance: PropTypes.number,\n        maxScale: PropTypes.number,\n        contentAspectRatio: PropTypes.number,\n        enableResistance: PropTypes.bool,\n        resistantStrHorizontal: PropTypes.oneOfType([\n            PropTypes.func,\n            PropTypes.number,\n            PropTypes.string\n        ]),\n        resistantStrVertical: PropTypes.oneOfType([\n            PropTypes.func,\n            PropTypes.number,\n            PropTypes.string\n        ]),\n        onTransformStart: PropTypes.func,\n        onViewTransformed: PropTypes.func,\n        onPinchTransforming: PropTypes.func,\n        onPinchStartReached: PropTypes.func,\n        onPinchEndReached: PropTypes.func,\n        onTransformGestureReleased: PropTypes.func,\n        onSwipeUpReleased: PropTypes.func,\n        onSwipeDownReleased: PropTypes.func,\n        onDoubleTapStartReached: PropTypes.func,\n        onDoubleTapEndReached: PropTypes.func,\n        onDoubleTapConfirmed: PropTypes.func,\n        onSingleTapConfirmed: PropTypes.func,\n        onLayout: PropTypes.func,\n        children: PropTypes.node,\n    };\n\n    static defaultProps = {\n        maxOverScrollDistance: 20,\n        enableScale: true,\n        enableTranslate: true,\n        enableTransform: true,\n        maxScale: 1,\n        enableResistance: false,\n        resistantStrHorizontal: (dx) => (dx /= 3),\n        resistantStrVertical: (dy) => (dy /= 3)\n    };\n\n    constructor (props) {\n        super(props);\n        this.state = {\n            // transform state\n            scale: 1,\n            translateX: 0,\n            translateY: 0,\n            // animation state\n            animator: new Animated.Value(0),\n            // layout\n            width: 0,\n            height: 0,\n            pageX: 0,\n            pageY: 0\n        };\n        this._viewPortRect = new Rect(); // A holder to avoid new too much\n\n        this.onLayout = this.onLayout.bind(this);\n        this.cancelAnimation = this.cancelAnimation.bind(this);\n        this.contentRect = this.contentRect.bind(this);\n        this.transformedContentRect = this.transformedContentRect.bind(this);\n        this.animate = this.animate.bind(this);\n        this.onResponderGrant = this.onResponderGrant.bind(this);\n        this.onResponderRelease = this.onResponderRelease.bind(this);\n        this.onResponderMove = this.onResponderMove.bind(this);\n\n        this.scroller = new Scrolling(true, (dx, dy, scroller) => {\n            if (dx === 0 && dy === 0 && scroller.isFinished()) {\n                this.animateBounce();\n                return;\n            }\n\n            this.updateTransform({\n                translateX: this.state.translateX + dx / this.state.scale,\n                translateY: this.state.translateY + dy / this.state.scale\n            });\n        });\n    }\n\n    viewPortRect () {\n        this._viewPortRect.set(0, 0, this.state.width, this.state.height);\n        return this._viewPortRect;\n    }\n\n    contentRect () {\n        let rect = this.viewPortRect().copy();\n        if (this.props.contentAspectRatio && this.props.contentAspectRatio > 0) {\n            rect = fitCenterRect(this.props.contentAspectRatio, rect);\n        }\n        return rect;\n    }\n\n    transformedContentRect () {\n        let rect = transformedRect(this.viewPortRect(), this.currentTransform());\n        if (this.props.contentAspectRatio && this.props.contentAspectRatio > 0) {\n            rect = fitCenterRect(this.props.contentAspectRatio, rect);\n        }\n        return rect;\n    }\n\n    currentTransform () {\n        return new Transform(this.state.scale, this.state.translateX, this.state.translateY);\n    }\n\n    componentDidMount () {\n        this.gestureResponder = createResponder({\n            onStartShouldSetResponder: (evt, gestureState) => true,\n            onMoveShouldSetResponderCapture: (evt, gestureState) => true,\n            // onMoveShouldSetResponder: this.handleMove,\n            onResponderMove: this.onResponderMove,\n            onResponderGrant: this.onResponderGrant,\n            onResponderRelease: this.onResponderRelease,\n            onResponderTerminate: this.onResponderRelease,\n            // Do not allow parent view to intercept gesture\n            onResponderTerminationRequest: (evt, gestureState) => false,\n            onResponderDoubleTapConfirmed: (evt, gestureState) => {\n                this.props.onDoubleTapConfirmed &&\n                    this.props.onDoubleTapConfirmed();\n            },\n            onResponderSingleTapConfirmed: (evt, gestureState) => {\n                this.props.onSingleTapConfirmed &&\n                    this.props.onSingleTapConfirmed();\n            }\n        });\n    }\n\n    componentDidUpdate (prevProps, prevState) {\n        this.props.onViewTransformed &&\n            this.props.onViewTransformed({\n                scale: this.state.scale,\n                translateX: this.state.translateX,\n                translateY: this.state.translateY\n            });\n    }\n\n    componentWillUnmount () {\n        this.cancelAnimation();\n    }\n\n    render () {\n        let gestureResponder = this.gestureResponder;\n        if (!this.props.enableTransform) {\n            gestureResponder = {};\n        }\n\n        return (\n            <View\n                style={{flex: 1}}\n                {...this.props}\n                {...gestureResponder}\n                ref={(component) => (this.innerViewRef = component)}\n                onLayout={this.onLayout}>\n                <View\n                    style={{\n                        flex: 1,\n                        transform: [\n                            { scale: this.state.scale },\n                            { translateX: this.state.translateX },\n                            { translateY: this.state.translateY }\n                        ]\n                    }}\n                >\n                    { this.props.children }\n                </View>\n            </View>\n        );\n    }\n\n    onLayout (e) {\n        const {width, height} = e.nativeEvent.layout;\n        if (width !== this.state.width || height !== this.state.height) {\n            this.setState({width, height});\n        }\n        this.measureLayout();\n\n        this.props.onLayout && this.props.onLayout(e);\n    }\n\n    measureLayout () {\n        let handle = findNodeHandle(this.innerViewRef);\n        NativeModules.UIManager.measure(handle, (x, y, width, height, pageX, pageY) => {\n            if (typeof pageX === \"number\" && typeof pageY === \"number\") { // avoid undefined values on Android devices\n                if (this.state.pageX !== pageX || this.state.pageY !== pageY) {\n                    this.setState({ pageX: pageX, pageY: pageY });\n                }\n            }\n        });\n    }\n\n    onResponderGrant (evt, gestureState) {\n        this.props.onTransformStart && this.props.onTransformStart();\n        this.setState({responderGranted: true});\n        this.measureLayout();\n    }\n\n    onResponderMove (evt, gestureState) {\n        this.cancelAnimation();\n\n        let dx = gestureState.moveX - gestureState.previousMoveX;\n        let dy = gestureState.moveY - gestureState.previousMoveY;\n        if (this.props.enableResistance) {\n            let d = this.applyResistance(dx, dy);\n            dx = d.dx;\n            dy = d.dy;\n        }\n\n        if (!this.props.enableTranslate) {\n            dx = dy = 0;\n        }\n\n        let transform = {};\n        if (gestureState.previousPinch && gestureState.pinch && this.props.enableScale) {\n            let scaleBy = gestureState.pinch / gestureState.previousPinch;\n            let pivotX = gestureState.moveX - this.state.pageX;\n            let pivotY = gestureState.moveY - this.state.pageY;\n            let rect = transformedRect(\n                transformedRect(\n                    this.contentRect(),\n                    this.currentTransform()\n                ),\n                new Transform(scaleBy, dx, dy, { x: pivotX, y: pivotY })\n            );\n            transform = getTransform(this.contentRect(), rect);\n            this.props.onPinchTransforming && this.props.onPinchTransforming(transform);\n        } else {\n            if (Math.abs(dx) > 2 * Math.abs(dy)) {\n                dy = 0;\n            } else if (Math.abs(dy) > 2 * Math.abs(dx)) {\n                dx = 0;\n            }\n            transform.translateX = this.state.translateX + dx / this.state.scale;\n            transform.translateY = this.state.translateY + dy / this.state.scale;\n        }\n\n        this.updateTransform(transform);\n\n        const curScale = this.state.scale;\n        if (curScale <= 1) {\n            this.props.onPinchStartReached &&\n                this.props.onPinchStartReached(transform);\n        }\n        if (curScale >= this.props.maxScale) {\n            this.props.onPinchEndReached &&\n                this.props.onPinchEndReached(transform);\n        }\n\n        return true;\n    }\n\n    onResponderRelease (evt, gestureState) {\n        const transform = {\n            scale: this.state.scale,\n            translateX: this.state.translateX,\n            translateY: this.state.translateY\n        };\n\n        if (gestureState.doubleTapUp) {\n            if (!this.props.enableScale) {\n                this.animateBounce();\n                return;\n            }\n            let pivotX = 0;\n            let pivotY = 0;\n            if (gestureState.dx || gestureState.dy) {\n                pivotX = gestureState.moveX - this.state.pageX;\n                pivotY = gestureState.moveY - this.state.pageY;\n            } else {\n                pivotX = gestureState.x0 - this.state.pageX;\n                pivotY = gestureState.y0 - this.state.pageY;\n            }\n\n            this.performDoubleTapUp(pivotX, pivotY);\n        } else {\n            if (this.props.enableTranslate) {\n                this.performFling(gestureState.vx, gestureState.vy);\n            } else {\n                this.animateBounce();\n            }\n        }\n\n        this.props.onTransformGestureReleased &&\n            this.props.onTransformGestureReleased(transform);\n\n        if (this.props.onSwipeUpReleased) {\n            if (this.state.scale === 1 && this.state.translateY < -150) {\n                this.props.onSwipeUpReleased(transform);\n            }\n        }\n        if (this.props.onSwipeDownReleased) {\n            if (this.state.scale === 1 && this.state.translateY > 150) {\n                this.props.onSwipeDownReleased(transform);\n            }\n        }\n    }\n\n    performFling (vx, vy) {\n        let startX = 0;\n        let startY = 0;\n        let maxX, minX, maxY, minY;\n        let availablePanDistance = availableTranslateSpace(\n            this.transformedContentRect(),\n            this.viewPortRect()\n        );\n        if (vx > 0) {\n            minX = 0;\n            if (availablePanDistance.left > 0) {\n                maxX = availablePanDistance.left +\n                    this.props.maxOverScrollDistance;\n            } else {\n                maxX = 0;\n            }\n        } else {\n            maxX = 0;\n            if (availablePanDistance.right > 0) {\n                minX = -availablePanDistance.right -\n                    this.props.maxOverScrollDistance;\n            } else {\n                minX = 0;\n            }\n        }\n        if (vy > 0) {\n            minY = 0;\n            if (availablePanDistance.top > 0) {\n                maxY = availablePanDistance.top +\n                    this.props.maxOverScrollDistance;\n            } else {\n                maxY = 0;\n            }\n        } else {\n            maxY = 0;\n            if (availablePanDistance.bottom > 0) {\n                minY = -availablePanDistance.bottom -\n                    this.props.maxOverScrollDistance;\n            } else {\n                minY = 0;\n            }\n        }\n\n        vx *= 1000; // per second\n        vy *= 1000;\n        if (Math.abs(vx) > 2 * Math.abs(vy)) {\n            vy = 0;\n        } else if (Math.abs(vy) > 2 * Math.abs(vx)) {\n            vx = 0;\n        }\n\n        this.scroller.fling(startX, startY, vx, vy, minX, maxX, minY, maxY);\n    }\n\n    performDoubleTapUp (pivotX, pivotY) {\n        let curScale = this.state.scale;\n        let scaleBy;\n        if (curScale > (1 + this.props.maxScale) / 2) {\n            scaleBy = 1 / curScale;\n        } else {\n            scaleBy = this.props.maxScale / curScale;\n        }\n\n        let rect = transformedRect(\n            this.transformedContentRect(),\n            new Transform(scaleBy, 0, 0, { x: pivotX, y: pivotY })\n        );\n        rect = transformedRect(\n            rect,\n            new Transform(\n                1,\n                this.viewPortRect().centerX() - pivotX,\n                this.viewPortRect().centerY() - pivotY\n            )\n        );\n        rect = alignedRect(rect, this.viewPortRect());\n        this.animate(rect);\n\n        if (\n            this.props.onDoubleTapStartReached ||\n            this.props.onDoubleTapEndReached\n        ) {\n            const transform = getTransform(this.contentRect(), rect);\n            if (curScale > (1 + this.props.maxScale) / 2) {\n                this.props.onDoubleTapStartReached &&\n                    this.props.onDoubleTapStartReached(transform);\n            } else {\n                this.props.onDoubleTapEndReached &&\n                    this.props.onDoubleTapEndReached(transform);\n            }\n        }\n    }\n\n    applyResistance (dx, dy) {\n        let availablePanDistance = availableTranslateSpace(\n            this.transformedContentRect(),\n            this.viewPortRect()\n        );\n\n        if ((dx > 0 && availablePanDistance.left < 0) ||\n        (dx < 0 && availablePanDistance.right < 0)) {\n            const { resistantStrHorizontal } = this.props;\n            switch (typeof resistantStrHorizontal) {\n                case \"function\":\n                    const returnValue = resistantStrHorizontal(dx);\n                    if (typeof returnValue === \"number\") {\n                        dx = returnValue;\n                        break;\n                    }\n                    if (typeof returnValue === \"string\") {\n                        dx = parseFloat(returnValue);\n                        break;\n                    }\n                    // eslint-disable-next-line no-console\n                    console.warn(\n                        \"react-native-gallery-swiper\",\n                        \"Invalid return value for 'resistantStrHorizontal' prop. \" +\n                        \"Expecting one of 'number' or 'string'.\"\n                    );\n                    dx = dx /= 3;\n                    break;\n                case \"number\":\n                    dx = resistantStrHorizontal;\n                    break;\n                case \"string\":\n                    dx = parseFloat(resistantStrHorizontal);\n                    break;\n                default:\n                    dx = dx /= 3;\n                    break;\n            }\n        }\n        if ((dy > 0 && availablePanDistance.top < 0) ||\n        (dy < 0 && availablePanDistance.bottom < 0)) {\n            const { resistantStrVertical } = this.props;\n            switch (typeof resistantStrVertical) {\n                case \"function\":\n                    const returnValue = resistantStrVertical(dx);\n                    if (typeof returnValue === \"number\") {\n                        dx = returnValue;\n                        break;\n                    }\n                    if (typeof returnValue === \"string\") {\n                        dx = parseFloat(returnValue);\n                        break;\n                    }\n                    // eslint-disable-next-line no-console\n                    console.warn(\n                        \"react-native-gallery-swiper\",\n                        \"Invalid return value for 'resistantStrVertical' prop. \" +\n                        \"Expecting one of 'number' or 'string'.\"\n                    );\n                    dx = dx /= 3;\n                    break;\n                case \"number\":\n                    dy = resistantStrVertical;\n                    break;\n                case \"string\":\n                    dy = parseFloat(resistantStrVertical);\n                    break;\n                default:\n                    dy = dy /= 3;\n                    break;\n            }\n        }\n\n        return { dx, dy };\n    }\n\n    cancelAnimation () {\n        this.state.animator.stopAnimation();\n    }\n\n    animate (targetRect, durationInMillis) {\n        let duration = 200;\n        if (durationInMillis) {\n            duration = durationInMillis;\n        }\n\n        let fromRect = this.transformedContentRect();\n        if (fromRect.equals(targetRect, 0.01)) {\n            return;\n        }\n\n        this.state.animator.removeAllListeners();\n        this.state.animator.setValue(0);\n        this.state.animator.addListener((state) => {\n            let progress = state.value;\n\n            let left = fromRect.left +\n                (targetRect.left - fromRect.left) * progress;\n            let right = fromRect.right +\n                (targetRect.right - fromRect.right) * progress;\n            let top = fromRect.top +\n                (targetRect.top - fromRect.top) * progress;\n            let bottom = fromRect.bottom +\n                (targetRect.bottom - fromRect.bottom) * progress;\n\n            let transform = getTransform(\n                this.contentRect(),\n                new Rect(left, top, right, bottom)\n            );\n            this.updateTransform(transform);\n        });\n\n        Animated.timing(\n            this.state.animator,\n            {\n                toValue: 1,\n                duration: duration,\n                easing: Easing.inOut(Easing.ease)\n            }\n        ).start();\n    }\n\n    animateBounce () {\n        let curScale = this.state.scale;\n        let minScale = 1;\n        let maxScale = this.props.maxScale;\n        let scaleBy = 1;\n        if (curScale > maxScale) {\n            scaleBy = maxScale / curScale;\n        } else if (curScale < minScale) {\n            scaleBy = minScale / curScale;\n        }\n\n        let rect = transformedRect(\n            this.transformedContentRect(),\n            new Transform(\n                scaleBy,\n                0,\n                0,\n                {\n                    x: this.viewPortRect().centerX(),\n                    y: this.viewPortRect().centerY()\n                }\n            )\n        );\n        rect = alignedRect(rect, this.viewPortRect());\n        this.animate(rect);\n    }\n\n    updateTransform (transform) {\n        this.setState(transform);\n    }\n\n    forceUpdateTransform (transform) {\n        this.setState(transform);\n    }\n\n    getAvailableTranslateSpace () {\n        return availableTranslateSpace(\n            this.transformedContentRect(),\n            this.viewPortRect()\n        );\n    }\n}\n"]},"metadata":{},"sourceType":"module"}